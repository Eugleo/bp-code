from typing import List, Optional, Tuple

from src.peptide import Mod

LYS = "KVFGRCELAAAMKRHGLDNYRGYSLGNWVCAAKFESNFNTQATNRNTDGSTDYGILQINSRWWCNDGRTPGSRNLCNIPCSALLSSDITASVNCAKKIVSDGNGMNAWVAWRNRCKGTDVQAWIRGCRL"

BSA = "DTHKSEIAHRFKDLGEEHFKGLVLIAFSQYLQQCPFDEHVKLVNELTEFAKTCVADESHAGCEKSLHTLFGDELCKVASLRETYGDMADCCEKQEPERNECFLSHKDDSPDLPKLKPDPNTLCDEFKADEKKFWGKYLYEIARRHPYFYAPELLYYANKYNGVFQECCQAEDKGACLLPKIETMREKVLTSSARQRLRCASIQKFGERALKAWSVARLSQKFPKAEFVEVTKLVTDLTKVHKECCHGDLLECADDRADLAKYICDNQDTISSKLKECCDKPLLEKSHCIAEVEKDAIPENLPPLTADFAEDKDVCKNYQEAKDAFLGSFLYEYSRRHPEYAVSVLLRLAKEYEATLEECCAKDDPHACYSTVFDKLKHLVDEPQNLIKQNCDQFEKLGEYGFQNALIVRYTRKVPQVSTPTLVEVSRSLGKVGTRCCTKPESERMPCTEDYLSLILNRLCVLHEKTPVSEKVTKCCTESLVNRRPCFSALTPDETYVPKAFDEKLFTFHADICTLPDTEKQIKKQTALVELLKHKPKATEEQLKTVMENFVAFVDKCCAADDKEACFAVEGPKLVVSTQTALA"

MYST = "KKLTKEGAAALCKMKHLADKVAKERSQELKDRTQNFAGYIEFELYRIDYWLEKLNGPKGRKDGYAKLSDSDIEKVKEIFNKAKDGITKQLPEAKKAGEEAGKLHTEVKKAAENARGQDLDDDTAKSTGLYRVLNWYCITKEERHNATPNCDGIQFRKHYLSVNRSAIDCSSTSYEENYDWSANALQVALNSWEDVKPKKLESAGSDKNCNIGQSSESHPCTMTEEWQTPYKETVEKLRELEDAYQRGKKAHDAMLGYANTAYAVNTKVEQEKPLTTGLEVLFQGPSAEPEA"

OVA = "GSIGAASMEFCFDVFKELKVHHANENIFYCPIAIMSALAMVYLGAKDSTRTQINKVVRFDKLPGFGDSIEAQCGTSVNVHSSLRDILNQITKPNDVYSFSLASRLYAEERYPILPEYLQCVKELYRGGLEPINFQTAADQARELINSWVESQTNGIIRNVLQPSSVDSQTAMVLVNAIVFKGLWEKAFKDEDTQAMPFRVTEQESKPVQMMYQIGLFRVASMASEKMKILELPFASGTMSMLVLLPDEVSGLEQLESIINFEKLTEWTSSNVMEERKIKVYLPRMKMEEKYNLTSVLMAMGITDVFSSSANLSGISSAESLKISQAVHAAHAEINEAGREVVGSAEAGVDAASVSEEFRADHPFLFCIKHIATNAVLFFGRCVSP"

LIP = "DDNLVGGMTLDLPSDAPPISLSSSTNSASDGGKVVAATTAQIQEFTKYAGIAATAYCRSVVPGNKWDCVQCQKWVPDGKIITTFTSLLSDTNGYVLRSDKQKTIYLVFRGTNSFRSAITDIVFNFSDYKPVKGAKVHAGFLSSYEQVVNDYFPVVQEQLTAHPTYKVIVTGHSLGGAQALLAGMDLYQREPRLSPKNLSIFTVGGPRVGNPTFAYYVESTGIPFQRTVHKRDIVPHVPPQSFGFLHPGVESWIKSGTSNVQICTSEIETKDCSNSIVPFTSILDHLSYFDINEGSCL"


def combine_modifications(
    modifications: List[List[Optional[Mod]]],
    starting_mass: float,
    target_mass: float,
    error_ppm: float = 10,
) -> List[List[Mod]]:
    result = []

    def go(i: int, current_mass: float, selection: Tuple[Mod, ...] = ()):
        if i == len(modifications):
            if within_bounds(current_mass, target_mass, error_ppm):
                result.append(selection)
        else:
            for m in modifications[i]:
                if m is None:  # None = no modification
                    go(i + 1, current_mass, selection)
                else:
                    go(i + 1, current_mass + m.mass, selection + (m,))

    go(0, current_mass=starting_mass)
    return list(set(result))


def within_bounds(reference_mass, measured_mass, error_ppm: float = 10):
    return abs(reference_mass - measured_mass) <= err_margin(reference_mass, error_ppm)


def err_margin(reference_mass, error_ppm: float = 10):
    return (error_ppm / 1e6) * reference_mass


def compute_error(reference_mass, measured_mass):
    return 1e6 * abs(measured_mass - reference_mass) / reference_mass
